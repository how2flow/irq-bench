From 0c594278e7b364f7b59590836235c67868ac2d5f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=EC=A0=95=EA=B4=91=ED=98=84=20=28Steve=20Jeong=29?=
 <steve.jeong@telechips.com>
Date: Mon, 4 Aug 2025 16:21:53 +0900
Subject: [PATCH 1/2] [fea] tcc807x: patch for tick capture

xen patch for tick capture

TCS: XXX-XXXX
---
 xen/arch/arm/arm64/entry.S | 19 +++++++++++++++++--
 xen/arch/arm/gic.c         |  3 +++
 xen/arch/arm/traps.c       | 24 ++++++++++++++++++++++++
 xen/include/xen/irq.h      | 10 ++++++++++
 4 files changed, 54 insertions(+), 2 deletions(-)

diff --git a/xen/arch/arm/arm64/entry.S b/xen/arch/arm/arm64/entry.S
index 95f1a92684..d7df5f5499 100644
--- a/xen/arch/arm/arm64/entry.S
+++ b/xen/arch/arm/arm64/entry.S
@@ -188,7 +188,7 @@
 
         .endm
 
-        .macro  exit, hyp, compat
+        .macro  exit, hyp, compat, trap=common
 
         .if \hyp == 0         /* Guest mode */
 
@@ -196,6 +196,11 @@
 
         exit_guest \compat
 
+        .ifc \trap, irq
+            mov     x0, #0x1
+            bl      do_trap_for_tick
+        .endif
+
         .endif
 
         b       return_from_trap
@@ -246,10 +251,20 @@
         cbnz    x19, 1f
         alternative_else_nop_endif
 
+        .ifc \trap, irq
+            mov     x0, #0x0
+            bl      do_trap_for_tick
+        .endif
+
         mov     x0, sp
         bl      do_trap_\trap
 1:
-        exit    hyp=0, compat=\compat
+        .ifc \trap, irq
+            exit    hyp=0, compat=\compat, trap=irq
+        .else
+            exit    hyp=0, compat=\compat
+        .endif
+
         .endm
 
 
diff --git a/xen/arch/arm/gic.c b/xen/arch/arm/gic.c
index 3b0331b538..029b90dc0a 100644
--- a/xen/arch/arm/gic.c
+++ b/xen/arch/arm/gic.c
@@ -39,6 +39,7 @@
 #include <asm/acpi.h>
 
 DEFINE_PER_CPU(uint64_t, lr_mask);
+extern DEFINE_PER_CPU(struct hyp_tick_raw, hyp_tick_raw);
 
 #undef GIC_DEBUG
 
@@ -388,6 +389,7 @@ void gic_interrupt(struct cpu_user_regs *regs, int is_fiq)
         {
             isb();
             do_IRQ(regs, irq, is_fiq);
+            this_cpu(hyp_tick_raw).irq = irq;
         }
         else if ( is_lpi(irq) )
         {
@@ -397,6 +399,7 @@ void gic_interrupt(struct cpu_user_regs *regs, int is_fiq)
         else if ( unlikely(irq < 16) )
         {
             do_sgi(regs, irq);
+            this_cpu(hyp_tick_raw).irq = irq;
         }
         else
         {
diff --git a/xen/arch/arm/traps.c b/xen/arch/arm/traps.c
index 219ab3c3fb..9fe92dd665 100644
--- a/xen/arch/arm/traps.c
+++ b/xen/arch/arm/traps.c
@@ -77,6 +77,7 @@ static int debug_stack_lines = 40;
 #define stack_words_per_line 4
 #endif
 
+DEFINE_PER_CPU(struct hyp_tick_raw, hyp_tick_raw);
 integer_param("debug_stack_lines", debug_stack_lines);
 
 static enum {
@@ -2260,6 +2261,29 @@ void do_trap_guest_serror(struct cpu_user_regs *regs)
     __do_trap_serror(regs, true);
 }
 
+void do_trap_for_tick(int flag)
+{
+    /* Capture tick */
+    if (!flag) {
+        this_cpu(hyp_tick_raw).tick_in = READ_SYSREG64(CNTPCT_EL0);
+        this_cpu(hyp_tick_raw).cpu_in = READ_SYSREG64(MPIDR_EL1);
+        this_cpu(hyp_tick_raw).cpu_in >>= 2;
+        this_cpu(hyp_tick_raw).cpu_in &= 0xff;
+    } else {
+        this_cpu(hyp_tick_raw).tick_out = READ_SYSREG64(CNTPCT_EL0);
+        this_cpu(hyp_tick_raw).cpu_out = READ_SYSREG64(MPIDR_EL1);
+        this_cpu(hyp_tick_raw).cpu_out >>= 2;
+        this_cpu(hyp_tick_raw).cpu_out &= 0xff;
+        /* Cal latency */
+        if (!this_cpu(hyp_tick_raw).flag) {
+            this_cpu(hyp_tick_raw).irq = 0;
+            this_cpu(hyp_tick_raw).flag = true;
+        } else {
+            this_cpu(hyp_tick_raw).latency_tick = this_cpu(hyp_tick_raw).tick_out - this_cpu(hyp_tick_raw).tick_in;
+        }
+    }
+}
+
 void do_trap_irq(struct cpu_user_regs *regs)
 {
     gic_interrupt(regs, 0);
diff --git a/xen/include/xen/irq.h b/xen/include/xen/irq.h
index 43d567fe44..7cb0936b18 100644
--- a/xen/include/xen/irq.h
+++ b/xen/include/xen/irq.h
@@ -174,4 +174,14 @@ unsigned int arch_hwdom_irqs(domid_t);
 void arch_evtchn_bind_pirq(struct domain *, int pirq);
 #endif
 
+struct hyp_tick_raw {
+    volatile uint16_t cpu_in;
+    volatile uint16_t cpu_out;
+    volatile uint64_t tick_in;
+    volatile uint64_t tick_out;
+    volatile uint64_t latency_tick;
+    volatile uint32_t irq;
+    bool flag;
+};
+
 #endif /* __XEN_IRQ_H__ */
-- 
2.25.1

